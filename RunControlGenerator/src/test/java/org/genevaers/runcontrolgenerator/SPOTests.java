/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.genevaers.runcontrolgenerator;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.io.IOException;
import java.nio.file.Paths;

/*
 * Copyright Contributors to the GenevaERS Project. SPDX-License-Identifier: Apache-2.0 (c) Copyright IBM Corporation 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */



import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;

import org.genevaers.genevaio.wbxml.RecordParser;
import org.genevaers.repository.Repository;
import org.genevaers.repository.components.ViewColumnSource;
import org.genevaers.repository.components.ViewSource;
import org.genevaers.runcontrolgenerator.configuration.RunControlConfigration;
import org.genevaers.runcontrolgenerator.repositorybuilders.RepositoryBuilder;
import org.genevaers.runcontrolgenerator.repositorybuilders.RepositoryBuilderFactory;
import org.genevaers.runcontrolgenerator.singlepassoptimiser.LogicGroup;
import org.genevaers.runcontrolgenerator.singlepassoptimiser.SinglePassOptimiser;
import org.genevaers.runcontrolgenerator.singlepassoptimiser.ViewSourceWrapper;
import org.genevaers.utilities.GenevaLog;
import org.genevaers.utilities.ParmReader;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import com.google.common.flogger.FluentLogger;

/**
 * Test various cominations of the inputs to the Simgle Pass Optimisation
 * processor.
 * 
 * Create an external helper build/or add to views bases on an initial WBXML
 * 
 * SPO Scenarios
 * Single View single input - simple
 * SV - none overlapping PF sets
 * SV - overlapping PF sets
 * SV - 2 sources same PF sets
 * SV set1 contains set2 2 and more
 * SV 3 overplapping sets.
 *  -> should end up with 7 logic groups
 * Combination of above with less than 7 resulting groups?
 */
public class SPOTests {
    private static final FluentLogger logger = FluentLogger.forEnclosingClass();

    private ParmReader pr;

    @BeforeEach
    public void initEach(TestInfo info){
        Repository.clearAndInitialise();
        RecordParser.clearAndInitialise();
        java.nio.file.Path target = Paths.get("target/test-logs/");
        target.toFile().mkdirs();
        GenevaLog.initLogger(RunCompilerTest.class.getName(), target.resolve(info.getDisplayName()).toString(), Level.FINE);
    }
    
    @Test public void testBaseSPO() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        assertEquals(1,  spo.getLogicGroups().size());
    }


    @Test public void testTwoNoneOverlappingSourcesSPO() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addNoneOverlappingSource();
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
        assert2LogicGroups(lgs);
        //assert the 2nd logic group
        assertLogicGroupViewSourceNumber(lgs.get(1), 0);
    }

    @Test public void testSPOForTwoTotallyOverlappingSourcesOnePF() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addOverlappingSource();
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
        assertOneLogicGroups(lgs);
        assertLogicGroupViewSourceNumber(lgs.get(0), 1);
    }


    @Test public void testSPOForTwoOverlappingSourcesOneSharedPF() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSources();
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
		lgs.stream().forEach(lg -> lg.logData());
        assertThreeLogicGroups(lgs);
        assertEquals(1, lgs.get(0).getSortedViewSources().size());
        assertEquals(1, lgs.get(1).getSortedViewSources().size());
        assertEquals(2, lgs.get(2).getSortedViewSources().size());
        assertLogicGroupViewSourceNumber(lgs.get(2), 1);
    }


    @Test public void testSPOForTwoOverlappingSourcesTwoSharedPF() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addSharedPFToViewSources();
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
		lgs.stream().forEach(lg -> lg.logData());
        assertThreeLogicGroups(lgs);
        assertEquals(1, lgs.get(0).getSortedViewSources().size());
        assertEquals(1, lgs.get(1).getSortedViewSources().size());
        assertEquals(2, lgs.get(2).getSortedViewSources().size());
        assertLogicGroupViewSourceNumber(lgs.get(2), 1);
    }

    @Test public void testSPOForThreeOverlappingSourcesTwoSharedPFsSets() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addSharedPFToViewSources();
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
		lgs.stream().forEach(lg -> lg.logData());
        assertEquals(5, lgs.size());
        assertEquals(1, lgs.get(0).getSortedViewSources().size());
        assertEquals(1, lgs.get(1).getSortedViewSources().size());
        assertEquals(2, lgs.get(2).getSortedViewSources().size());
        assertEquals(1, lgs.get(3).getSortedViewSources().size());
        assertEquals(3, lgs.get(4).getSortedViewSources().size());
        assertLogicGroupViewSourceNumber(lgs.get(2), 1);
        assertLogicGroupViewSourceNumber(lgs.get(4), 2);
    }

    @Test public void testSPOForThreeOverlappingSourcesTwoSharedPFsSets2() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSourcesStartAt(3);
        TestHelper.addSharedPFToViewSourcesStartAt(3);
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
		lgs.stream().forEach(lg -> lg.logData());
        assertEquals(4, lgs.size());
        assertEquals(1, lgs.get(0).getSortedViewSources().size());
        assertEquals(1, lgs.get(1).getSortedViewSources().size());
        assertEquals(1, lgs.get(2).getSortedViewSources().size());
        assertEquals(2, lgs.get(3).getSortedViewSources().size());
        assertLogicGroupViewSourceNumber(lgs.get(3), 1);
    }

    @Test public void testSPOForThreeOverlappingSourcesTwoSharedPFsSets3() {
        TestHelper.setupWithBaseView();
        readConfigAndBuildRepo();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addSharedPFToViewSources();
        TestHelper.addNoneOverlappingSource();
        TestHelper.addSharedPFToViewSourcesStartAt(2);
        TestHelper.addSharedPFToViewSourcesStartAt(2);
        SinglePassOptimiser spo = new SinglePassOptimiser();
        spo.run();
        List<LogicGroup> lgs = spo.getLogicGroups();
		lgs.stream().forEach(lg -> lg.logData());
        assertEquals(5, lgs.size());
        assertEquals(1, lgs.get(0).getSortedViewSources().size());
        assertEquals(1, lgs.get(1).getSortedViewSources().size());
        assertEquals(2, lgs.get(2).getSortedViewSources().size());
        assertEquals(1, lgs.get(3).getSortedViewSources().size());
        assertEquals(2, lgs.get(4).getSortedViewSources().size());
        assertLogicGroupViewSourceNumber(lgs.get(4), 1);
    }

    private void assertThreeLogicGroups(List<LogicGroup> lgs) {
        assertEquals(3, lgs.size());
    }


    private void readConfigAndBuildRepo() {
        pr = new ParmReader();
        pr.setConfig(new RunControlConfigration());
        try {
            pr.populateConfigFrom(TestHelper.getTestParmName());
            Repository.clearAndInitialise();
            RepositoryBuilder rb = RepositoryBuilderFactory.get();
            rb.run();
        } catch (IOException e) {
			logger.atSevere().log("readConfigAndBuildRepo error %s", e.getMessage());
        }
    }

    private void assertLogicGroupViewSourceNumber(LogicGroup lg, int vsNumber) {
        List<ViewSourceWrapper> vss = lg.getSortedViewSources();
        ViewSource vs = vss.get(vsNumber).getViewSource();
        assertEquals("Filter me good",  vs.getExtractFilter());
        assertEquals(14, vs.getValuesOfColumnSourcesByNumber().size());
        Iterator<ViewColumnSource> vcsi = vs.getValuesOfColumnSourcesByNumber().iterator();
        while(vcsi.hasNext()) {
            ViewColumnSource vcs = vcsi.next();
            assertEquals("Column = " + vcs.getColumnNumber(),  vcs.getLogicText());
        }
    }


    private void assert2LogicGroups(List<LogicGroup> lgs) {
        assertEquals(2, lgs.size());
    }

    private void assertOneLogicGroups(List<LogicGroup> lgs) {
        assertEquals(1, lgs.size());
    }


}
