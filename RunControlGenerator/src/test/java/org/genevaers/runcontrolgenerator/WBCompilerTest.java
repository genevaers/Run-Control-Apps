/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.genevaers.runcontrolgenerator;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.IOException;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.Iterator;
import java.util.logging.Level;

import org.genevaers.compilers.extract.astnodes.ExtractAST2Dot;
import org.genevaers.compilers.extract.astnodes.ExtractBaseAST;
import org.genevaers.genevaio.dbreader.DatabaseConnection.DbType;
import org.genevaers.genevaio.dbreader.DBReader;
import org.genevaers.genevaio.dbreader.DatabaseConnection;
import org.genevaers.genevaio.dbreader.DatabaseConnectionParams;
import org.genevaers.genevaio.dbreader.PostgresConnection;
import org.genevaers.genevaio.ltfactory.LtFactoryHolder;
import org.genevaers.genevaio.ltfile.LTLogger;
import org.genevaers.genevaio.ltfile.LogicTable;
import org.genevaers.genevaio.wbxml.RecordParser;
import org.genevaers.repository.Repository;
import org.genevaers.repository.calculationstack.CalcStack;
import org.genevaers.repository.components.ViewColumn;
import org.genevaers.repository.components.ViewColumnSource;
import org.genevaers.repository.components.ViewNode;
import org.genevaers.repository.components.ViewSource;
import org.genevaers.repository.components.enums.ColumnSourceType;
import org.genevaers.repository.components.enums.DataType;
import org.genevaers.repository.components.enums.DateCode;
import org.genevaers.repository.components.enums.ExtractArea;
import org.genevaers.repository.components.enums.JustifyId;
import org.genevaers.repository.components.enums.ViewType;
import org.genevaers.repository.data.CompilerMessageSource;
import org.genevaers.repository.data.ViewLogicDependency.LogicType;
import org.genevaers.runcontrolgenerator.compilers.ExtractPhaseCompiler;
import org.genevaers.runcontrolgenerator.configuration.RunControlConfigration;
import org.genevaers.runcontrolgenerator.repositorybuilders.RepositoryBuilder;
import org.genevaers.runcontrolgenerator.repositorybuilders.RepositoryBuilderFactory;
import org.genevaers.runcontrolgenerator.utility.Status;
import org.genevaers.runcontrolgenerator.workbenchinterface.ColumnData;
import org.genevaers.runcontrolgenerator.workbenchinterface.LRData;
import org.genevaers.runcontrolgenerator.workbenchinterface.LRFieldData;
import org.genevaers.runcontrolgenerator.workbenchinterface.ViewColumnSourceData;
import org.genevaers.runcontrolgenerator.workbenchinterface.ViewData;
import org.genevaers.runcontrolgenerator.workbenchinterface.ViewSourceData;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerFactory;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerType;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractColumnCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractFilterCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractOutputCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBFormatCalculationCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBFormatFilterCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WorkbenchCompiler;
import org.genevaers.utilities.GenevaLog;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;

/*
 * Copyright Contributors to the GenevaERS Project. SPDX-License-Identifier: Apache-2.0 (c) Copyright IBM Corporation 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import com.google.common.flogger.FluentLogger;

  /* 
   * !!!!!  READ ME !!!!!!!!!!!!!
   * 
   * These test cheat in that they builds the Repository from the WB XML 
   * which replaces all the WB calls building the repo.
   * Then it calls the compiler on the different extract sections
   * The WBCompiler will then interact with the database.
   * This means that before the tests can be run the WBCompilerTest.xml 
   * file must be imported into a workbench environment.
   * The TEST_ENVIRONMENT and TEST_ENVIRONMENT_NUM constants must be set to
   * 
   * By default the tests are Disabled. 
   * Remove/comment out the Disabled tag to run
   * 
   * !!!!!  READ ME !!!!!!!!!!!!!
   */
  class WBCompilerTest extends RunCompilerBase {
  private static final FluentLogger logger = FluentLogger.forEnclosingClass();
  private int environmentid;
  private int lrid;
  private int lfid;
  private static int vcsdNum = 1;

  private static final String TEST_ENVIRONMENT = "7";
  private static final int TEST_ENVIRONMENT_NUM = 7;
  private static final int TEST_VIEW_NUM = 12044;

  @BeforeEach
  public void initEach(TestInfo info) {
    new RunControlConfigration();
    Repository.setGenerationTime(Calendar.getInstance().getTime());
    RecordParser.clearAndInitialise();
    LtFactoryHolder.getLtFunctionCodeFactory().clearAccumulatorMap();
    java.nio.file.Path target = Paths.get("target/test-logs/");
    target.toFile().mkdirs();
    GenevaLog.initLogger(RunCompilerTest.class.getName(), target.resolve(info.getDisplayName()).toString(), Level.FINE);

    WorkbenchCompiler.reset();
    DatabaseConnectionParams params = getPostgresParams();
    params.setEnvironmentID(TEST_ENVIRONMENT);
    WorkbenchCompiler.setSQLConnection(getTestDatabaseConnection(params));
    WorkbenchCompiler.setSchema("gendev");
    WorkbenchCompiler.setEnvironment(TEST_ENVIRONMENT_NUM);
  }

  @AfterEach
  public void afterEach(TestInfo info) {
    GenevaLog.closeLogger(WBCompilerTest.class.getName());
  }

  @Test  @Disabled
  void testWBCompileView() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());
    simulateActivationOfTheTestView();
    ExtractAST2Dot.write(ExtractPhaseCompiler.getXltRoot(), TestHelper.getMR91dotPath());
    assertEquals(0, Repository.getCompilerErrors().size());
    LogicTable xlt = WorkbenchCompiler.getXlt();
    System.out.println(LTLogger.logRecords(xlt));
  }

  @Test  @Disabled
  void testAssignFieldTwice() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    ViewColumnSource vcs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(5);
    vcs.setLogicText("COLUMN = {Binary8} + {Binary8}");

    simulateActivationOfTheTestView();

    //The point if this test is to ensure there is only one dependency for the field per column
    assertEquals(1, Repository.getDependencyCache().getDependenciesStream().filter(d -> d.getLrFieldId() == 96729).count());
  }

  @Test  @Disabled
  void testBadField() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    ViewColumnSource vcs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(5);
    vcs.setLogicText("COLUMN = {Bad}");

    simulateActivationOfTheTestView();

    assertEquals(1, Repository.getCompilerErrors().size());
    assertTrue(Repository.getCompilerErrors().get(0).getDetail().contains("Unknown field {Bad}"));
    assertNull(Repository.getDependencyCache().getNamedField("Bad"));
  }

  @Test  @Disabled
  void testBadSyntax() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    ViewColumnSource vcs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(5);
    vcs.setLogicText("COLUMN = gobbledegook");

    simulateActivationOfTheTestView();
    assertEquals(1, WorkbenchCompiler.getErrors().size());
    assertTrue(WorkbenchCompiler.getErrors().get(0).contains("gobbledegook"));
  }

  @Test  @Disabled
  void testNoWrite() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    vs.setExtractOutputLogic("");

    simulateActivationOfTheTestView();
    assertEquals(1, WorkbenchCompiler.getErrors().size());
    assertTrue(WorkbenchCompiler.getErrors().get(0).contains("No write"));
  }

  @Test  @Disabled
  void testColumnNotAssigned() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    ViewColumnSource vcs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(5);
    vcs.setLogicText("'COLUMN = gobbledegook");

    simulateActivationOfTheTestView();
    ExtractAST2Dot.write(ExtractPhaseCompiler.getXltRoot(), TestHelper.getMR91dotPath());
    assertEquals(0, Repository.getCompilerErrors().size());
    LogicTable xlt = WorkbenchCompiler.getXlt();
    System.out.println(LTLogger.logRecords(xlt));
    assertEquals(1, WorkbenchCompiler.getWarnings().size());
    assertTrue(WorkbenchCompiler.getWarningMessages().get(0).getDetail().contains("not assigned"));
    assertTrue(WorkbenchCompiler.getWarningMessages().get(0).getSource() == CompilerMessageSource.COLUMN);
  }

  @Test  @Disabled
  void testColumnAssignedViaReference() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    ViewColumnSource vcs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(4);
    vcs.setLogicText("'assigned from col 5");
    ViewColumnSource vcs5 = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(5);
    vcs5.setLogicText("COLUMN = 77\n COL.4=23");

    simulateActivationOfTheTestView();
    ExtractAST2Dot.write(ExtractPhaseCompiler.getXltRoot(), TestHelper.getMR91dotPath());
    assertEquals(0, Repository.getCompilerErrors().size());
    LogicTable xlt = WorkbenchCompiler.getXlt();
    System.out.println(LTLogger.logRecords(xlt));
    assertEquals(0, WorkbenchCompiler.getWarnings().size());
  }

  @Test  @Disabled
  void testColumnOverwriteViaReference() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    // Change logic content of a column
    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    ViewColumnSource vcs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(4);
    vcs.setLogicText("COLUMN = 77");
    ViewColumnSource vcs5 = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1).findFromColumnSourcesByNumber(5);
    vcs5.setLogicText("COLUMN = 77\n COL.4=23");

    simulateActivationOfTheTestView();
    ExtractAST2Dot.write(ExtractPhaseCompiler.getXltRoot(), TestHelper.getMR91dotPath());
    assertEquals(0, Repository.getCompilerErrors().size());
    LogicTable xlt = WorkbenchCompiler.getXlt();
    System.out.println(LTLogger.logRecords(xlt));
    assertEquals(1, WorkbenchCompiler.getWarnings().size());
    assertTrue(WorkbenchCompiler.getWarningMessages().get(0).getDetail().contains("Overwriting column 4"));
    assertTrue(WorkbenchCompiler.getWarningMessages().get(0).getColumnNumber() == 5);
  }

  @Test  @Disabled
  void testWriteExit() throws IOException {
    loadRepoFrom(TestHelper.WBCOMPILER_TEST);
    assertEquals(1, Repository.getViews().size());

    ViewSource vs = Repository.getViews().get(TEST_VIEW_NUM).getViewSource((short)1); 
    vs.setExtractOutputLogic("WRITE(SOURCE=DATA,DEST=FILE={ExtractOut.ExtractOut}, USEREXIT={writeExit})");

    simulateActivationOfTheTestView();
    assertEquals(1, WorkbenchCompiler.getErrors().size());
    assertEquals(0, Repository.getCompilerErrors().size());
    assertEquals(14544, Repository.getDependencyCache().getPfAssocID("ExtractOut.ExtractOut"));
    assertEquals(472, Repository.getDependencyCache().getExitIDs().iterator().next());
    assertEquals(1, Repository.getDependencyCache().getDependenciesStream().filter(d -> d.getFileAssociationId() != null &&  d.getFileAssociationId() == 14544 && d.getLogicTextType() == LogicType.EXTRACT_RECORD_OUTPUT).count());
    assertEquals(1, Repository.getDependencyCache().getDependenciesStream().filter(d -> d.getUserExitRoutineId() != null && d.getUserExitRoutineId() == 472 && d.getLogicTextType() == LogicType.EXTRACT_RECORD_OUTPUT).count());

    LogicTable xlt = WorkbenchCompiler.getXlt();
    System.out.println(LTLogger.logRecords(xlt));

  }

  @Test  @Disabled
  void testWriteExitModule() throws IOException {
    // new RunControlConfigration();
    WorkbenchCompiler.reset();
    assertEquals(0, Repository.getCompilerErrors().size());
    environmentid = 4;
    lrid = 1762;
    lfid = 1506;
    DatabaseConnectionParams params = getPostgresParams();
    params.setEnvironmentID(Integer.toString(environmentid));
    WorkbenchCompiler.setSQLConnection(getTestDatabaseConnection(params));
    WorkbenchCompiler.setSchema("gendev");
    WorkbenchCompiler.setEnvironment(environmentid);
    WorkbenchCompiler.setSourceLRID(lrid);
    WorkbenchCompiler.setSourceLFID(lfid);assertEquals(1, Repository.getLogicalRecords().size());
    assertEquals(18, Repository.getFields().size());

    ViewData view = makeView(999, "TestView");
    ColumnData cd = makeColumnData(view, 111, 1);
    ViewSourceData vsd = makeViewSource(1762, view);
    vsd.setOutputLogic("WRITE(SOURCE=DATA,DEST=FILE={ExtractOut.ExtractOut}, PROCEDURE={ginger})");

    ViewColumnSourceData vcs = makeViewColumnSource(1762, view, cd, "COLUMN = {AllTypeLookup.Binary1}");

    WBExtractOutputCompiler extractCompiler = (WBExtractOutputCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_OUTPUT);
    WorkbenchCompiler.addView(view);
    WorkbenchCompiler.addViewSource(vsd);
    WorkbenchCompiler.addViewColumnSource(vcs);
    WorkbenchCompiler.addColumn(cd);

    extractCompiler.run();
    ExtractAST2Dot.write(ExtractPhaseCompiler.getXltRoot(), TestHelper.getMR91dotPath());

    assertEquals(0, Repository.getCompilerErrors().size());
    assertEquals(14544, Repository.getDependencyCache().getPfAssocID("ExtractOut.ExtractOut"));
    assertEquals(472, Repository.getDependencyCache().getExitIDs().iterator().next());
    assertEquals(1, Repository.getDependencyCache().getDependenciesStream().filter(d -> d.getFileAssociationId() != null &&  d.getFileAssociationId() == 14544).count());
    assertEquals(1, Repository.getDependencyCache().getDependenciesStream().filter(d -> d.getUserExitRoutineId() != null && d.getUserExitRoutineId() == 472).count());
    LogicTable xlt = WorkbenchCompiler.getXlt();
    System.out.println(LTLogger.logRecords(xlt));

  }


  @Test  @Disabled
  void testFormatCalculationBad() throws IOException {
    // new RunControlConfigration();
    ViewData view = makeView(999, "TestView");
    ColumnData cd = makeColumnData(view, 111, 3);
    ViewSourceData vsd = makeViewSource(lrid, view);
    cd.setColumnCalculation("COLUMN = Col.1 + !");

    WBFormatCalculationCompiler fcc = (WBFormatCalculationCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.FORMAT_CALCULATION);
    WorkbenchCompiler.addView(view);
    WorkbenchCompiler.addViewSource(vsd);
    //WorkbenchCompiler.addViewColumnSource(vcs);
    WorkbenchCompiler.addColumn(cd);
    fcc.generateCalcStack(999, 3);
    assertTrue(fcc.hasSyntaxErrors());
    assertEquals(1, fcc.getSyntaxErrors().size());

  }

  @Test  @Disabled
  void testFormatFilterBad() throws IOException {
    new RunControlConfigration();
    ViewData view = makeView(999, "TestView");
    view.setFormatFilter("SKIPIF(COL.1 < ! and COL.3 > 5)");
    ViewSourceData vsd = makeViewSource(lrid, view);

    WBFormatFilterCompiler ffc = (WBFormatFilterCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.FORMAT_FILTER);
    WorkbenchCompiler.addView(view);
    WorkbenchCompiler.addViewSource(vsd);
    ffc.generateCalcStack(999);

    assertTrue(ffc.hasSyntaxErrors());
    assertEquals(2, Repository.getCompilerErrors().size());
  }

  private ViewColumnSourceData makeViewColumnSource(int rcgLR, ViewData view, ColumnData vc,
      String logicText) {
    ViewColumnSourceData vcsd = new ViewColumnSourceData();
    vcsd.setComponentId(vcsdNum++);
    vcsd.setColumnId(vc.getColumnId());
    vcsd.setColumnNumber(vc.getColumnNumber());
    vcsd.setLogicText(logicText);
    vcsd.setSequenceNumber((short) 1);
    vcsd.setSourceTypeValue(ColumnSourceType.LOGICTEXT.ordinal());
    vcsd.setViewSourceId(1);
    vcsd.setViewID(view.getId());
    vcsd.setViewSourceLrId(rcgLR);
    return vcsd;
  }

  private ColumnData makeColumnData(ViewData view, int colID, int columnNum) {
    ColumnData ci = new ColumnData();
    ci.setColumnNumber(columnNum);
    ci.setColumnId(colID);
    ci.setDataTypeValue(DataType.ALPHANUMERIC.ordinal());
    ci.setDateCodeValue(DateCode.NONE.ordinal());
    ci.setNumDecimalPlaces((short) 0);
    ci.setExtractAreaValue(ExtractArea.AREADATA.ordinal());
    ci.setStartPosition((short) 1);
    ci.setLength((short) 19);
    ci.setName("Test Field");
    ci.setAlignment(JustifyId.NONE.ordinal());
    ci.setRounding((short) 0);
    ci.setSigned(false);
    ci.setStartPosition((short) 1);
    ci.setViewID(view.getId());
    return ci;
  }

  private ViewSourceData makeViewSource(int rcgLR, ViewData view) {
    ViewSourceData vs = new ViewSourceData();
    vs.setId(1);
    vs.setViewID(view.getId());
    vs.setExtractFilter("");
    vs.setSequenceNumber((short) 1);
    vs.setSourceLrId(rcgLR);
    return vs;
  }

  private ViewData makeView(int viewID, String name) {
    ViewData vd = new ViewData();
    vd.setId(viewID);
    vd.setName(name);
    vd.setTypeValue(ViewType.EXTRACT.ordinal());
    return vd;
  }

  private LRData makeLRData(int id, String name) {
    LRData lr = new LRData();
    lr.setId(id);
    lr.setName(name);
    return lr;
  }

  private LRFieldData makeField(int lrid, int id, String name, DataType type, DateCode dateCode, short length,
      short position, short decimals, short scaling, boolean signed) {
    LRFieldData lrf = new LRFieldData();
    lrf.setId(id);
    lrf.setDataTypeValue(type.ordinal());
    lrf.setDateCodeValue(dateCode.ordinal());
    lrf.setLength(length);
    lrf.setLrId(lrid);
    lrf.setName(name);
    lrf.setNumDecimals(decimals);
    lrf.setRounding(scaling);
    lrf.setSigned(signed);
    lrf.setPosition(position);
    return lrf;
  }

  public static DatabaseConnectionParams getPostgresParams() {
    DatabaseConnectionParams params = new DatabaseConnectionParams();
    params.setDbType(DbType.POSTGRES);
    params.setDatabase("genevaers");
    params.setPort("5432");
    params.setSchema("gendev");
    params.setServer("localhost");
    params.setUsername("postgres");
    params.setPassword("postgres");
    return params;
  }

  public static Connection getTestDatabaseConnection(DatabaseConnectionParams params) {
    DatabaseConnection pgCon = new PostgresConnection(params);
    try {
      pgCon.connect();
    } catch (SQLException e) {
      // TODO Auto-generated catch block
      e.printStackTrace();
    }
    return pgCon.getConnection();
  }

  private void simulateActivationOfTheTestView() {
    ViewNode v = Repository.getViews().get(TEST_VIEW_NUM);
    ViewSource vs = v.getViewSource((short)1);
    WBExtractFilterCompiler filterCompiler = (WBExtractFilterCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_FILTER);
    WorkbenchCompiler.setCurrentViewSource(vs);
    filterCompiler.buildAST();

    Iterator<ViewColumnSource> vcsi = vs.getIteratorForColumnSourcesByNumber();
    while (vcsi.hasNext()) {
      ViewColumnSource vcs = vcsi.next();
      WBExtractColumnCompiler columnCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
      WorkbenchCompiler.setCurrentColumnNumber(vcs.getColumnNumber());
      columnCompiler.buildAST();
    }

    WBExtractOutputCompiler recordCompiler = (WBExtractOutputCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_OUTPUT);
    recordCompiler.buildAST();

    WorkbenchCompiler.buildTheExtractTableIfThereAreNoErrors();
  }

}
