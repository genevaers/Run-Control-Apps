/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.genevaers.runcontrolgenerator;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.Calendar;
import java.util.logging.Level;

import org.genevaers.compilers.extract.astnodes.ExtractBaseAST;
import org.genevaers.genevaio.ltfactory.LtFactoryHolder;
import org.genevaers.genevaio.ltfile.LTLogger;
import org.genevaers.genevaio.ltfile.LogicTable;
import org.genevaers.genevaio.wbxml.RecordParser;
import org.genevaers.repository.Repository;
import org.genevaers.repository.components.enums.ColumnSourceType;
import org.genevaers.repository.components.enums.DataType;
import org.genevaers.repository.components.enums.DateCode;
import org.genevaers.repository.components.enums.ExtractArea;
import org.genevaers.repository.components.enums.JustifyId;
import org.genevaers.repository.components.enums.ViewType;
import org.genevaers.runcontrolgenerator.configuration.RunControlConfigration;
import org.genevaers.runcontrolgenerator.workbenchinterface.ColumnData;
import org.genevaers.runcontrolgenerator.workbenchinterface.LRData;
import org.genevaers.runcontrolgenerator.workbenchinterface.LRFieldData;
import org.genevaers.runcontrolgenerator.workbenchinterface.ViewColumnSourceData;
import org.genevaers.runcontrolgenerator.workbenchinterface.ViewData;
import org.genevaers.runcontrolgenerator.workbenchinterface.ViewSourceData;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerFactory;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerType;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractColumnCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractFilterCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractOutputCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WorkbenchCompiler;
import org.genevaers.utilities.GenevaLog;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

/*
 * Copyright Contributors to the GenevaERS Project. SPDX-License-Identifier: Apache-2.0 (c) Copyright IBM Corporation 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import com.google.common.flogger.FluentLogger;

/**
 *  Build on the SPO Tests
 *  Check the AST Tree built as a result
 */
class WBCompilerTest extends RunCompilerBase {
    private static final FluentLogger logger = FluentLogger.forEnclosingClass();

    @BeforeEach
    public void initEach(TestInfo info){
        new RunControlConfigration();
        WorkbenchCompiler.reset();
        RunControlConfigration.set(RunControlConfigration.DOT_XLT, "Y");
        Repository.clearAndInitialise();
        ExtractBaseAST.setCurrentColumnNumber((short)0);
        ExtractBaseAST.setCurrentAccumNumber(0);
        Repository.setGenerationTime(Calendar.getInstance().getTime());
        RecordParser.clearAndInitialise();
        LtFactoryHolder.getLtFunctionCodeFactory().clearAccumulatorMap();
        java.nio.file.Path target = Paths.get("target/test-logs/");
        target.toFile().mkdirs();
        GenevaLog.initLogger(WBCompilerTest.class.getName(), target.resolve(info.getDisplayName()).toString(), Level.FINE);
    }

    @AfterEach
    public void afterEach(TestInfo info){
		GenevaLog.closeLogger(WBCompilerTest.class.getName());
    }

    
    @Test void testAssignField() throws IOException {
      new RunControlConfigration();
        LRData rcgLR = makeLRData(777, "TestLR");

        String fieldName = "TestAlnumField";
        LRFieldData lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

        ViewData view = makeView(999, "TestView");
        ColumnData cd = makeColumnData(view, 111);
        ViewSourceData vsd = makeViewSource(rcgLR, view);
        

        ViewColumnSourceData vcs = makeViewColumnSource(rcgLR, lrf, view, cd, "COLUMN = {" + lrf.getName() + "}");

        WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
		    WorkbenchCompiler.addLR(rcgLR);
        WorkbenchCompiler.addLRField(lrf);
        WorkbenchCompiler.addView(view);
        WorkbenchCompiler.addViewSource(vsd);
        WorkbenchCompiler.addViewColumnSource(vcs);
        WorkbenchCompiler.addColumn(cd);

        extractCompiler.run();
        assertEquals(0, Repository.getCompilerErrors().size());

        LogicTable xlt = extractCompiler.getXlt();
        System.out.println(LTLogger.logRecords(xlt));
        
    }

    @Test void testBadField() throws IOException {
      LRData rcgLR = makeLRData(777, "TestLR");

      String fieldName = "TestAlnumField";
      LRFieldData lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

      ViewData view = makeView(999, "TestView");
      ColumnData cd = makeColumnData(view, 111);
      ViewSourceData vsd = makeViewSource(rcgLR, view);

      ViewColumnSourceData vcs = makeViewColumnSource(rcgLR, lrf, view, cd, "COLUMN = {Bad}");

      WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
      WorkbenchCompiler.addLR(rcgLR);
      WorkbenchCompiler.addLRField(lrf);
      WorkbenchCompiler.addView(view);
      WorkbenchCompiler.addViewSource(vsd);
      WorkbenchCompiler.addViewColumnSource(vcs);
      WorkbenchCompiler.addColumn(cd);

      extractCompiler.run();
      assertEquals(1, Repository.getCompilerErrors().size());
      assertTrue(Repository.getCompilerErrors().get(0).getDetail().contains("Unknown field {Bad}"));
    }

    @Test void testBadSyntax() throws IOException {
      LRData rcgLR = makeLRData(777, "TestLR");

      String fieldName = "TestAlnumField";
      LRFieldData lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

      ViewData view = makeView(999, "TestView");
      ColumnData cd = makeColumnData(view, 111);
      ViewSourceData vsd = makeViewSource(rcgLR, view);
      

      ViewColumnSourceData vcs = makeViewColumnSource(rcgLR, lrf, view, cd, "COLUMN = gobbledegook");

      WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
      WorkbenchCompiler.addLR(rcgLR);
      WorkbenchCompiler.addLRField(lrf);
      WorkbenchCompiler.addView(view);
      WorkbenchCompiler.addViewSource(vsd);
      WorkbenchCompiler.addViewColumnSource(vcs);
      WorkbenchCompiler.addColumn(cd);

      extractCompiler.run();
      assertEquals(1, Repository.getCompilerErrors().size());
      assertTrue(Repository.getCompilerErrors().get(0).getDetail().contains("gobbledegook"));
    }

    @Test void testFilter() throws IOException {
      new RunControlConfigration();
        LRData rcgLR = makeLRData(777, "TestLR");

        String fieldName = "TestAlnumField";
        LRFieldData lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

        ViewData view = makeView(999, "TestView");
        ViewSourceData vsd = makeViewSource(rcgLR, view);
        vsd.setExtractFilter("SELECTIF({TestAlnumField} > 0)");
        vsd.setOutputLogic("");
        
        WBExtractFilterCompiler extractCompiler = (WBExtractFilterCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_FILTER);
		    WorkbenchCompiler.addLR(rcgLR);
        WorkbenchCompiler.addLRField(lrf);
        WorkbenchCompiler.addView(view);
        WorkbenchCompiler.addViewSource(vsd);

        extractCompiler.run();
        assertEquals(0, Repository.getCompilerErrors().size());

        LogicTable xlt = extractCompiler.getXlt();
        System.out.println(LTLogger.logRecords(xlt));
        
    }

    @Test void testOutput() throws IOException {
      new RunControlConfigration();
        LRData rcgLR = makeLRData(777, "TestLR");

        String fieldName = "TestAlnumField";
        LRFieldData lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

        ViewData view = makeView(999, "TestView");
        ColumnData cd = makeColumnData(view, 111);
        ViewSourceData vsd = makeViewSource(rcgLR, view);
        vsd.setOutputLogic("WRITE(SOURCE=DATA,DEST=DEFAULT)");
        
        WBExtractOutputCompiler extractCompiler = (WBExtractOutputCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_OUTPUT);
		    WorkbenchCompiler.addLR(rcgLR);
        WorkbenchCompiler.addLRField(lrf);
        WorkbenchCompiler.addView(view);
        WorkbenchCompiler.addViewSource(vsd);

        extractCompiler.run();
        assertEquals(0, Repository.getCompilerErrors().size());

        LogicTable xlt = extractCompiler.getXlt();
        System.out.println(LTLogger.logRecords(xlt));
    }

    @Test void testSELECTIFContext() throws IOException {
      new RunControlConfigration();
        LRData rcgLR = makeLRData(777, "TestLR");

        String fieldName = "TestAlnumField";
        LRFieldData lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

        ViewData view = makeView(999, "TestView");
        ColumnData cd = makeColumnData(view, 111);
        ViewSourceData vsd = makeViewSource(rcgLR, view);
        

        ViewColumnSourceData vcs = makeViewColumnSource(rcgLR, lrf, view, cd, "SELECTIF({field} > 0)\n COLUMN = {" + lrf.getName() + "}");

        WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
		    WorkbenchCompiler.addLR(rcgLR);
        WorkbenchCompiler.addLRField(lrf);
        WorkbenchCompiler.addView(view);
        WorkbenchCompiler.addViewSource(vsd);
        WorkbenchCompiler.addViewColumnSource(vcs);
        WorkbenchCompiler.addColumn(cd);

        extractCompiler.run();
        assertEquals(1, Repository.getCompilerErrors().size());
        assertTrue(Repository.getCompilerErrors().get(0).getDetail().contains("SELECTIF"));        
    }


    private ViewColumnSourceData makeViewColumnSource(LRData rcgLR, LRFieldData lrf, ViewData view, ColumnData vc, String logicText) {
      ViewColumnSourceData vcsd = new ViewColumnSourceData();
      vcsd.setColumnId(vc.getColumnId());
      vcsd.setColumnNumber(vc.getColumnNumber());
      vcsd.setLogicText(logicText);
      vcsd.setSequenceNumber((short)1);
      vcsd.setSourceTypeValue(ColumnSourceType.LOGICTEXT.ordinal());
      vcsd.setViewSourceId(1);
      vcsd.setViewID(view.getId());
      vcsd.setViewSourceLrId(rcgLR.getId());
      return vcsd;
    }

    private ColumnData makeColumnData(ViewData view, int colID) {
      ColumnData ci = new ColumnData();
      ci.setColumnNumber(1);
      ci.setColumnId(colID);
      ci.setDataTypeValue(DataType.ALPHANUMERIC.ordinal());
      ci.setDateCodeValue(DateCode.NONE.ordinal());
      ci.setNumDecimalPlaces((short)0);
      ci.setExtractAreaValue(ExtractArea.AREADATA.ordinal());
      ci.setStartPosition((short)1);
      ci.setLength((short)19);
      ci.setName("Test Field");
      ci.setAlignment(JustifyId.NONE.ordinal());
      ci.setRounding((short)0);
      ci.setSigned(false);
      ci.setStartPosition((short)1);
      ci.setViewID(view.getId());
      return ci;
    }

    private ViewSourceData makeViewSource(LRData rcgLR, ViewData view) {
      ViewSourceData vs = new ViewSourceData();
      vs.setId(1);
      vs.setViewID(view.getId());
      vs.setExtractFilter("");
      vs.setSequenceNumber((short)1);
      vs.setSourceLrId(rcgLR.getId());
      return vs;
    }

    private ViewData makeView(int viewID, String name) {
      ViewData vd = new ViewData();
      vd.setId(viewID);
      vd.setName(name);
      vd.setTypeValue(ViewType.EXTRACT.ordinal());
      return vd;
    }

    private LRData makeLRData(int id, String name) {
      LRData lr = new LRData();
      lr.setId(id);
      lr.setName(name);
      return lr;
    }

    private LRFieldData makeField(int lrid, int id, String name, DataType type, DateCode dateCode, short length, short position, short decimals, short scaling, boolean signed) {
		LRFieldData lrf = new LRFieldData();
		lrf.setId(id);
		lrf.setDataTypeValue(type.ordinal());
		lrf.setDateCodeValue(dateCode.ordinal());
		lrf.setLength(length);
		lrf.setLrId(lrid);
		lrf.setName(name);
		lrf.setNumDecimals(decimals);
		lrf.setRounding(scaling);
		lrf.setSigned(signed);
		lrf.setPosition(position);
		return lrf;
    }


}
