/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.genevaers.runcontrolgenerator;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.nio.file.Paths;
import java.util.Calendar;
import java.util.logging.Level;

import org.fusesource.jansi.AnsiRenderer.Code;
import org.genevaers.compilers.extract.astnodes.ASTFactory;
import org.genevaers.compilers.extract.astnodes.ErrorAST;
import org.genevaers.compilers.extract.astnodes.ExtractBaseAST;
import org.genevaers.genevaio.ltfactory.LtFactoryHolder;
import org.genevaers.genevaio.ltfile.LTLogger;
import org.genevaers.genevaio.ltfile.LTRecord;
import org.genevaers.genevaio.ltfile.LogicTable;
import org.genevaers.genevaio.ltfile.LogicTableArg;
import org.genevaers.genevaio.ltfile.LogicTableF0;
import org.genevaers.genevaio.ltfile.LogicTableF1;
import org.genevaers.genevaio.ltfile.LogicTableF2;
import org.genevaers.genevaio.ltfile.LogicTableNV;
import org.genevaers.genevaio.ltfile.LogicTableNameF1;
import org.genevaers.genevaio.ltfile.LogicTableRE;
import org.genevaers.genevaio.ltfile.LogicTableWR;
import org.genevaers.genevaio.wbxml.RecordParser;
import org.genevaers.repository.Repository;
import org.genevaers.repository.components.LRField;
import org.genevaers.repository.components.LogicalRecord;
import org.genevaers.repository.components.ViewNode;
import org.genevaers.repository.components.enums.DataType;
import org.genevaers.repository.components.enums.DateCode;
import org.genevaers.repository.data.ComponentCollection;
import org.genevaers.repository.jltviews.UniqueKeys;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerFactory;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerType;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractColumnCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractFilterCompiler;
import org.genevaers.utilities.GenevaLog;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

/*
 * Copyright Contributors to the GenevaERS Project. SPDX-License-Identifier: Apache-2.0 (c) Copyright IBM Corporation 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import com.google.common.flogger.FluentLogger;

/**
 *  Build on the SPO Tests
 *  Check the AST Tree built as a result
 */
class WBCompilerTest extends RunCompilerBase {
    private static final FluentLogger logger = FluentLogger.forEnclosingClass();

    @BeforeEach
    public void initEach(TestInfo info){
        Repository.clearAndInitialise();
        ExtractBaseAST.setCurrentColumnNumber((short)0);
        ExtractBaseAST.setCurrentAccumNumber(0);
        Repository.setGenerationTime(Calendar.getInstance().getTime());
        RecordParser.clearAndInitialise();
        LtFactoryHolder.getLtFunctionCodeFactory().clearAccumulatorMap();
        java.nio.file.Path target = Paths.get("target/test-logs/");
        target.toFile().mkdirs();
        GenevaLog.initLogger(WBCompilerTest.class.getName(), target.resolve(info.getDisplayName()).toString(), Level.FINE);
    }

    @AfterEach
    public void afterEach(TestInfo info){
		GenevaLog.closeLogger(WBCompilerTest.class.getName());
    }

    
    @Test void testAssignField() {
        // Not from CompilerBase.... make a WBCompilerBase?
        // Add a source LR in the way WB will
        WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);

        LogicalRecord rcgLR = new LogicalRecord();
		rcgLR.setComponentId(777);
		rcgLR.setName("WBSourceLR1");
		extractCompiler.addLR(rcgLR);
        LRField lrf = makeField(777, 33, "TestAlnumField", DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);
        extractCompiler.addField(lrf);

        // Going to need a view and view column which uses the above LR Field in the column
        // Can't just read a WB XML as it will populate the repo
        // We want to simulate a lazy VDP getting just what it needs
        
        // Or do we use a PG database as a test - need to be preloaded etc

        // so from the WB Activator's pov how does the view info get in there?
        // What is needed?

        // What do we call to do the compilation?

        // The compilation should build the AST and add it to the VS node under the LF node.
        // Then we emit from the base node

        // Call WBExtractColumnCompiler in way WB will

        // Look for result and dependencies
    }

    private LRField makeField(int lrid, int id, String name, DataType type, DateCode dateCode, short length, short position, short decimals, short scaling, boolean signed) {
		LRField lrf = new LRField();
		lrf.setComponentId(id);
		lrf.setDatatype(type);
		lrf.setDateTimeFormat(dateCode);
		lrf.setLength(length);
		lrf.setLrID(lrid);
		lrf.setName(name);
		lrf.setNumDecimalPlaces(decimals);
		lrf.setRounding(scaling);
		lrf.setSigned(signed);
		lrf.setStartPosition(position);
		return lrf;
    }


}
