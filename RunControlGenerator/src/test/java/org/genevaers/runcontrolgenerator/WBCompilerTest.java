/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.genevaers.runcontrolgenerator;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.Calendar;
import java.util.logging.Level;

import org.fusesource.jansi.AnsiRenderer.Code;
import org.genevaers.compilers.extract.astnodes.ASTFactory;
import org.genevaers.compilers.extract.astnodes.ErrorAST;
import org.genevaers.compilers.extract.astnodes.ExtractBaseAST;
import org.genevaers.genevaio.ltfactory.LtFactoryHolder;
import org.genevaers.genevaio.ltfile.LTLogger;
import org.genevaers.genevaio.ltfile.LTRecord;
import org.genevaers.genevaio.ltfile.LogicTable;
import org.genevaers.genevaio.ltfile.LogicTableArg;
import org.genevaers.genevaio.ltfile.LogicTableF0;
import org.genevaers.genevaio.ltfile.LogicTableF1;
import org.genevaers.genevaio.ltfile.LogicTableF2;
import org.genevaers.genevaio.ltfile.LogicTableNV;
import org.genevaers.genevaio.ltfile.LogicTableNameF1;
import org.genevaers.genevaio.ltfile.LogicTableRE;
import org.genevaers.genevaio.ltfile.LogicTableWR;
import org.genevaers.genevaio.wbxml.RecordParser;
import org.genevaers.repository.Repository;
import org.genevaers.repository.components.LRField;
import org.genevaers.repository.components.LogicalRecord;
import org.genevaers.repository.components.ViewColumn;
import org.genevaers.repository.components.ViewColumnSource;
import org.genevaers.repository.components.ViewDefinition;
import org.genevaers.repository.components.ViewNode;
import org.genevaers.repository.components.ViewSource;
import org.genevaers.repository.components.enums.ColumnSourceType;
import org.genevaers.repository.components.enums.DataType;
import org.genevaers.repository.components.enums.DateCode;
import org.genevaers.repository.components.enums.ExtractArea;
import org.genevaers.repository.components.enums.JustifyId;
import org.genevaers.repository.components.enums.ViewType;
import org.genevaers.repository.data.ComponentCollection;
import org.genevaers.repository.jltviews.UniqueKeys;
import org.genevaers.runcontrolgenerator.configuration.RunControlConfigration;
import org.genevaers.runcontrolgenerator.workbenchinterface.ColumnInfo;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerFactory;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBCompilerType;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractColumnCompiler;
import org.genevaers.runcontrolgenerator.workbenchinterface.WBExtractFilterCompiler;
import org.genevaers.utilities.GenevaLog;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

/*
 * Copyright Contributors to the GenevaERS Project. SPDX-License-Identifier: Apache-2.0 (c) Copyright IBM Corporation 2008.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInfo;

import com.google.common.flogger.FluentLogger;

/**
 *  Build on the SPO Tests
 *  Check the AST Tree built as a result
 */
class WBCompilerTest extends RunCompilerBase {
    private static final FluentLogger logger = FluentLogger.forEnclosingClass();

    @BeforeEach
    public void initEach(TestInfo info){
        new RunControlConfigration();
        RunControlConfigration.set(RunControlConfigration.DOT_XLT, "Y");
        Repository.clearAndInitialise();
        ExtractBaseAST.setCurrentColumnNumber((short)0);
        ExtractBaseAST.setCurrentAccumNumber(0);
        Repository.setGenerationTime(Calendar.getInstance().getTime());
        RecordParser.clearAndInitialise();
        LtFactoryHolder.getLtFunctionCodeFactory().clearAccumulatorMap();
        java.nio.file.Path target = Paths.get("target/test-logs/");
        target.toFile().mkdirs();
        GenevaLog.initLogger(WBCompilerTest.class.getName(), target.resolve(info.getDisplayName()).toString(), Level.FINE);
    }

    @AfterEach
    public void afterEach(TestInfo info){
		GenevaLog.closeLogger(WBCompilerTest.class.getName());
    }

    
    @Test void testAssignField() throws IOException {
      new RunControlConfigration();
        LogicalRecord rcgLR = makeLR(777, "TestLR");

        String fieldName = "TestAlnumField";
        LRField lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

        ViewNode view = makeView(999, "TestView");
        createAndAddViewSourceToView(rcgLR, view);
        ViewColumn vc = makeAndAddColumntoView(view, 111);
        ViewColumnSource vcs = addViewColumnSourceToView(rcgLR, lrf, view, vc, "COLUMN = {" + lrf.getName() + "}");

        WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
        extractCompiler.setViewDetails(1, view.getID(), ViewType.EXTRACT);
		    extractCompiler.addLR(rcgLR);
        extractCompiler.addField(lrf);
        
        ColumnInfo ci = getColumnInfo(vc);
        extractCompiler.setColumnInfo(ci);

        extractCompiler.compileViewColumnSource(vcs);
        assertEquals(0, Repository.getCompilerErrors().size());

        LogicTable xlt = extractCompiler.getXlt();
        System.out.println(LTLogger.logRecords(xlt));
        
    }

    @Test void testBadField() throws IOException {
      LogicalRecord rcgLR = makeLR(777, "TestLR");

      String fieldName = "TestAlnumField";
      LRField lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

      ViewNode view = makeView(999, "TestView");
      createAndAddViewSourceToView(rcgLR, view);
      ViewColumn vc = makeAndAddColumntoView(view, 111);
      ViewColumnSource vcs = addViewColumnSourceToView(rcgLR, lrf, view, vc, "COLUMN = {Bad}");

      WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
      extractCompiler.setViewDetails(1, view.getID(), ViewType.EXTRACT);
      extractCompiler.addLR(rcgLR);
      extractCompiler.addField(lrf);
      
      ColumnInfo ci = getColumnInfo(vc);
      extractCompiler.setColumnInfo(ci);

      extractCompiler.compileViewColumnSource(vcs);
      assertEquals(1, Repository.getCompilerErrors().size());
      assertTrue(Repository.getCompilerErrors().get(0).getDetail().contains("Unknown field {Bad}"));
    }

    @Test void testBadSyntax() throws IOException {
      LogicalRecord rcgLR = makeLR(777, "TestLR");

      String fieldName = "TestAlnumField";
      LRField lrf = makeField(777, 33, fieldName, DataType.ALPHANUMERIC, DateCode.NONE, (short)19, (short)3, (short)0, (short)0, false);

      ViewNode view = makeView(999, "TestView");
      createAndAddViewSourceToView(rcgLR, view);
      ViewColumn vc = makeAndAddColumntoView(view, 111);
      ViewColumnSource vcs = addViewColumnSourceToView(rcgLR, lrf, view, vc, "COLUMN = gobbledegook");

      WBExtractColumnCompiler extractCompiler = (WBExtractColumnCompiler) WBCompilerFactory.getProcessorFor(WBCompilerType.EXTRACT_COLUMN);
      extractCompiler.setViewDetails(1, view.getID(), ViewType.EXTRACT);
      extractCompiler.addLR(rcgLR);
      extractCompiler.addField(lrf);
      
      ColumnInfo ci = getColumnInfo(vc);
      extractCompiler.setColumnInfo(ci);

      extractCompiler.compileViewColumnSource(vcs);
      assertEquals(1, Repository.getCompilerErrors().size());
      assertTrue(Repository.getCompilerErrors().get(0).getDetail().contains("gobbledegook"));
    }

  private ColumnInfo getColumnInfo(ViewColumn vc) {
      ColumnInfo ci = new ColumnInfo();
      ci.setColumnId(vc.getComponentId());
      ci.setColumnNumber(vc.getColumnNumber());
      ci.setDataType(vc.getDataType());
      ci.setDateCode(vc.getDateCode());
      ci.setExtractArea(vc.getExtractArea());
      ci.setLength(vc.getFieldId());
      ci.setAlignment(vc.getJustifyId());
      ci.setNumDecimalPlaces(vc.getDecimalCount());
      ci.setRounding(vc.getRounding());
      ci.setSigned(vc.isSigned());
      ci.setStartPosition(vc.getStartPosition());
      return ci;
    }

    private ViewColumnSource addViewColumnSourceToView(LogicalRecord rcgLR, LRField lrf, ViewNode view, ViewColumn vc, String logicText) {
      ViewColumnSource vcs = new ViewColumnSource();
      vcs.setColumnID(vc.getComponentId());
      vcs.setColumnNumber(vc.getColumnNumber());
      vcs.setComponentId(123);
//        vcs.setLogicText("COLUMN = {" + fieldName + "}");
      vcs.setLogicText(logicText);
      vcs.setSequenceNumber((short)1);
      vcs.setSourceType(ColumnSourceType.LOGICTEXT);
      vcs.setViewSourceId(1);
      vcs.setViewId(view.getID());
      vcs.setViewSrcLrFieldId(lrf.getComponentId());
      vcs.setViewSrcLrId(rcgLR.getComponentId());
      
      view.addViewColumnSource(vcs);
      return vcs;
    }

    private ViewColumn makeAndAddColumntoView(ViewNode view, int colID) {
      //Auto inc Id and column Numbers?
      //Could manage postions too
      ViewColumn vc = new ViewColumn();
      vc.setColumnNumber(1);
      vc.setComponentId(colID);
      vc.setDataType(DataType.ALPHANUMERIC);
      vc.setDateCode(DateCode.NONE);
      vc.setDecimalCount((short)0);
      vc.setExtractArea(ExtractArea.AREADATA);
      vc.setExtractAreaPosition((short)1);
      vc.setFieldLength((short)19);
      vc.setFieldName("Test Field");
      vc.setHeaderJustifyId(JustifyId.NONE);
      vc.setRounding((short)0);
      vc.setSigned(false);
      vc.setStartPosition((short)1);
      vc.setViewId(view.getID());
      view.addViewColumn(vc);
      return vc;
    }

    private ViewSource createAndAddViewSourceToView(LogicalRecord rcgLR, ViewNode view) {
      ViewSource vs = new ViewSource();
      vs.setComponentId(1);
      vs.setViewId(view.getID());
      vs.setExtractFilter("");
      vs.setSequenceNumber((short)1);
      vs.setSourceLRID(rcgLR.getComponentId());
      view.addViewSource(vs);
      return vs;
    }

    private ViewNode makeView(int viewID, String name) {
      ViewDefinition vd = new ViewDefinition();
      vd.setComponentId(viewID);
      vd.setName(name);
      vd.setViewType(ViewType.EXTRACT);
      return Repository.getViewNodeMakeIfDoesNotExist(vd);
    }

    private LogicalRecord makeLR(int id, String name) {
      LogicalRecord lr = new LogicalRecord();
      lr.setComponentId(id);
      lr.setName(name);
      return lr;
    }

    private LRField makeField(int lrid, int id, String name, DataType type, DateCode dateCode, short length, short position, short decimals, short scaling, boolean signed) {
		LRField lrf = new LRField();
		lrf.setComponentId(id);
		lrf.setDatatype(type);
		lrf.setDateTimeFormat(dateCode);
		lrf.setLength(length);
		lrf.setLrID(lrid);
		lrf.setName(name);
		lrf.setNumDecimalPlaces(decimals);
		lrf.setRounding(scaling);
		lrf.setSigned(signed);
		lrf.setStartPosition(position);
		return lrf;
    }


}
